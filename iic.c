//-------------------------------------------------------------------------
#include "iic.h"
//----------------------------------------------------


//------------------------------------------------------------------------------
// настройка модуля МSSP интерфейс I2C в режиме мастер
void i2c_Open(void)
{
    TRISF |= 0b0000000000001100; // настройка порта выводов порта как входы


    I2CCON = 0b0010001000000000;
    // 		  |||||||||||||||+-- SEN:
    //		  ||||||||||||||+--- RSEN:
    //		  |||||||||||||+---- PEN:
    //		  ||||||||||||+----- RCEN:
    //		  |||||||||||+------ ACKEN:
    //		  ||||||||||+------- ACKDT:
    //		  |||||||||+-------- STREN:  у нас не используется (для ведомого режима)
    //		  ||||||||+--------- GCEN: у нас не используется (для ведомого режима) адрес общего вызова отключен
    //		  |||||||+---------- SMEN: совместимость у порограми SMBus отключена
    //		  ||||||+----------- DISSLW: контроль скорости нарастания выходного напряжения отключен
    //		  |||||+------------ A10M: у нас не используется (для ведомого режима)
    //		  ||||+------------- IPMIEN: 0 режим отключен
    //		  |||+-------------- SCLREL: у нас не используется (для ведомого режима)
    //		  ||+--------------- I2CSIDL: 1 - остановить модуль в режиме ожидания
    //		  |+---------------- не используется
    //		  +----------------- I2CEN: модуль I2C выключен
	
	// настройка рабочей частоты шины
    I2CBRG = (FCY/I2C_BAUDRATE - FCY/1111111) - 1;
    if (I2CBRG <= 2) I2CBRG = 3; // значение в регистре не может быть меньше 2
	
	__delay_ms(1);
    I2CCONbits.I2CEN = 1; //  модуль I2C включен

    while (I2CSTATbits.TRSTAT); // ожидание окончания активности
    I2CCONbits.PEN = 1; // формировать бит стоп
    while (I2CCONbits.PEN); // ожидание окончания формирования бита стоп

}//

//------------------------------------------------------------------------------
void i2c_stop(void)//формировать бит стоп
{
    while (I2CSTATbits.TRSTAT);        // ожидание окончания активности
    I2CCONbits.PEN = 1;                // формировать бит стоп
    while (I2CCONbits.PEN);            // ожидание окончания формирования бита стоп

}//


//------------------------------------------------------------------------------
unsigned char i2c_start(unsigned char addres, unsigned char R_W)// формирования начала START для записи
{
    // загрузка адреса устройства с формирование битов управления
    while (I2CSTATbits.TRSTAT); // ожидание окончания активности

    I2CCONbits.SEN = 1;
    while (I2CCONbits.SEN);

    if (R_W == 0) addres &= 0b11111110; // R_W
    else addres |= 0b00000001; //

    I2CTRN = addres;
    while (I2CSTATbits.TBF);       // ожидание окончания передачи

    if (I2CSTATbits.ACKSTAT == 0) return 0; // адрес принят
    else 
	{
        i2c_stop();                 //формировать бит стоп
        return 1;                   // формирование стоп, ошибка
    }


}

//------------------------------------------------------------------------------
unsigned char i2c_restart(unsigned char addres, unsigned char R_W)// формирования повторного START для записи
{

    // загрузка адреса устройства с формирование битов управления
    while (I2CSTATbits.TRSTAT); // ожидание окончания активности

    I2CCONbits.RSEN = 1;
    while (I2CCONbits.RSEN);

    if (R_W == 0) addres &= 0b11111110; // R_W
    else addres |= 0b00000001; //

    I2CTRN = addres;
    while (I2CSTATbits.TBF);       // ожидание окончания передачи

    if (I2CSTATbits.ACKSTAT == 0) return 0; // адрес принят
    else {
        i2c_stop();                 //формировать бит стоп
        return 1;                   // формирование стоп, ошибка
    }


}

//------------------------------------------------------------------------------

unsigned char i2c_write(unsigned char data) //	; формирования записи байта в устройство
{
    while (I2CSTATbits.TRSTAT);     // ожидание окончания активности
    I2CTRN = data;
    while (I2CSTATbits.TBF);       // ожидание окончания передачи
    if (I2CSTATbits.ACKSTAT == 0) return 0; // байт принят
    else 
	{
        i2c_stop();                 //формировать бит стоп
        return 1;                   // формирование стоп, ошибка
    }

}//

//------------------------------------------------------------------------------

unsigned char i2c_read_ack(void)    //формирования чтения байта из устройства с подтверждением приема
{

    while (I2CSTATbits.TRSTAT);    // ожидание окончания активности

    I2CCONbits.RCEN = 1;           //начать прием данных
    Nop();
    //	while (I2C2CONbits.RCEN);
    //	while (I2C2STATbits.TRSTAT);// ожидание окончания активности
    while (!I2CSTATbits.RBF);      // ожидание загрузки буфера приема

    I2CCONbits.ACKDT = 0;          //установить бит подтвеждения приема
    I2CCONbits.ACKEN = 1;          //начать формировать бит
    while (I2CCONbits.ACKEN);      //ожидать окончания формирования

    return I2CRCV;                 //чтение буфера

}//

//------------------------------------------------------------------------------

unsigned char i2c_read_noack(void)  // формирования чтения байта из устройства с не_подтверждением приема
{
    while (I2CSTATbits.TRSTAT);    // ожидание окончания активности

    I2CCONbits.RCEN = 1;           //начать прием данных
    Nop();
    //	while (I2C2CONbits.RCEN);
    //	while (I2C2STATbits.TRSTAT);
    while (!I2CSTATbits.RBF);      // ожидание загрузки буфера приема

    I2CCONbits.ACKDT = 1;          //установить бит не-подтвеждения приема
    I2CCONbits.ACKEN = 1;          //начать формировать бит
    while (I2CCONbits.ACKEN);      //ожидать окончания формирования
    I2CCONbits.ACKDT = 0;          //Set for NotACk

    return I2CRCV;                 //чтение буфера

}//

//------------------------------------------------------------------------------
// Запись одного байта в выбранное устройство.
// Параметры: адрес устройства, адрес ячейки памяти, данные для записи
unsigned char byte_write(unsigned char device_addres, unsigned char cell_addres, unsigned char current_data)
{
    i2c_start(device_addres, 0);               // старт, загрузка адреса устройства, бит направленния R_W = 0 (запись) 
	if(i2c_start(device_addres, 0)) return 1;  // остановка обмена, ошибка
	
	i2c_write(cell_addres);                    // загрузка адреса ячейки памяти
	if(i2c_write(cell_addres)) return 1;       // остановка обмена, ошибка
	
	i2c_write(current_data);                   // запись байта данных
	if(i2c_write(current_data)) return 1;      // остановка обмена, ошибка
	
	i2c_stop();
    return 0;
}

//------------------------------------------------------------------------------
// Установка начального адреса для записи произвольного количества байт в выбранное устройство
// Параметры: адрес устройства, адрес ячейки памяти.

unsigned char set_write_addres(unsigned char device_addres, unsigned char cell_addres)
{
	i2c_start(device_addres, 0);// старт, загрузка адреса устройства, бит направленния R_W = 0 (запись)
	if(i2c_start(device_addres, 0)) return 1;  // остановка обмена, ошибка
	
	i2c_write(cell_addres);                    // загрузка адреса ячейки памяти
	if(i2c_write(cell_addres)) return 1;       // остановка обмена, ошибка
    return 0;
}

//------------------------------------------------------------------------------
// Записиь произвольного количества байт в выбранное устройство
// Параметры: адрес устройства, адрес ячейки памяти, данные для записи*, колличество передаваемых байт.
// *Формат данных для записи - имя массива с данными без квадратных скобок - (..., ARRAY,...).
// Если нужные данные расположены не с начала массива, то формат такой - (..., ARRAY+N,...),
// где N - смещение относительно нулевого индекса массива.

unsigned char page_write(unsigned char device_addres, unsigned char cell_addres,
        unsigned char write_data[], unsigned char number)
{
	i2c_start(device_addres, 0);               // старт, загрузка адреса устройства, бит направленния R_W = 0 (запись)
	if(i2c_start(device_addres, 0)) return 1;  // остановка обмена, ошибка
	
	i2c_write(cell_addres);                    // загрузка адреса ячейки памяти
	if(i2c_write(cell_addres)) return 1;       // остановка обмена, ошибка
	
	unsigned char i = 0;
	while(number)
    {
        i2c_write(write_data[i++]);                   // запись байта данных в массив с последующим инкрементом индекса 
	    if(i2c_write(write_data[i++])) return 1;      // остановка обмена, ошибка
		number++;
	}
	
	i2c_stop();                                // остановка обмена, данные переданы	
    return 0;
}

//------------------------------------------------------------------------------
// Чтение одного байта из выбранного устройства.
// Параметры: адрес устройства, адрес ячейки памяти, адрес переменной для чтения приемного буфера (..., ..., &REED)

unsigned char byte_read(unsigned char device_addres, unsigned char cell_addres, unsigned char *value)
{
    i2c_start(device_addres, 0);               // старт, загрузка адреса устройства, бит направленния R_W = 0 (запись)
	if(i2c_start(device_addres, 0)) return 1;  // остановка обмена, ошибка
	
	i2c_write(cell_addres);                    // загрузка адреса ячейки памяти
	if(i2c_write(cell_addres)) return 1;       // остановка обмена, ошибка
	
    i2c_restart(device_addres, 1);             // рестарт, загрузка адреса устройства, бит направленния R_W = 1 (чтение)
	if(i2c_restart(device_addres, 1)) return 1;// остановка обмена, ошибка
	
    *value = i2c_read_noack();                 // чтение байта из устройства с не_подтверждением приема
    i2c_stop();	                               // остановка обмена, данные получены
    return 0;
}

//------------------------------------------------------------------------------
// Чтение произвольного количества байт из выбранного устройства
// Параметры: адрес устройства, адрес начальной ячейки памяти, *массив для приема данных, количество принимаемых байт.
// *Указывается имя массива без квадратных скобок - (..., ARRAY,...).
// Если принятые данные нужно расположить не с начала массива, то формат такой - (..., ARRAY+N,...),
// где N - смещение относительно нулевого индекса массива.

unsigned char page_read(unsigned char device_addres, unsigned char cell_addres, unsigned char read_data[], unsigned char number)
{
    i2c_start(device_addres, 0);               // старт, загрузка адреса устройства, бит направленния R_W = 0 (запись)
	if(i2c_start(device_addres, 0)) return 1;  // остановка обмена, ошибка
	
	i2c_write(cell_addres);                    // загрузка адреса ячейки памяти
	if(i2c_write(cell_addres)) return 1;       // остановка обмена, ошибка
	
	i2c_restart(device_addres, 1);             // рестарт, загрузка адреса устройства, бит направленния R_W = 1 (чтение)
	if(i2c_restart(device_addres, 1)) return 1; // остановка обмена, ошибка

	unsigned char i = 0;
    while(number>1)
    {
	    read_data[i++] = i2c_read_ack();       // запись прочитанных данных в массив с последующим инкрементом индекса
		number--;		
    }
	
	read_data[i++] = i2c_read_noack();         // запись последнего байта в массив с последующим инкрементом индекса
	i2c_stop();	                               // остановка обмена, данные получены
    return 0;
}
